"""
Markdown templates for provenance card generation.

This module provides templates and helper functions for generating
human-readable provenance documentation in Markdown format.
"""

from datetime import datetime
from typing import Any, Dict, List, Optional


# =============================================================================
# Main Card Template
# =============================================================================

CARD_TEMPLATE = '''# Provenance Card

## Session Information
{session_info}

## Data Sources
{sources_section}

## License Analysis
{license_section}

## Sample Statistics
{stats_section}

## Batch Summary
{batch_section}

## Audit Trail
{audit_section}

---
Generated by Origin v{version} at {generated_at}
'''


# =============================================================================
# Section Templates
# =============================================================================

SECTION_TEMPLATES = {
    "session_info": """| Property | Value |
|----------|-------|
| Session ID | `{session_id}` |
| Created | {created_at} |
| Status | {status} |
| Config Hash | `{config_hash}` |
""",

    "sources_empty": "No data sources recorded for this session.",

    "license_result": """**Overall License**: {result_license}

**Permissions**: {permissions}

**Restrictions**: {restrictions}

**Conditions**: {conditions}
""",

    "license_conflicts": """### Conflicts Detected

{conflicts}
""",

    "license_warnings": """### Warnings

{warnings}
""",

    "license_clean": "No license conflicts detected.",

    "stats": """| Metric | Value |
|--------|-------|
| Total Batches | {batch_count} |
| Total Samples | {sample_count} |
| Unique Samples | {unique_samples} |
| Total Data Size | {total_bytes} |
""",

    "batch_header": """| Batch Index | Fingerprint | Sample Count | Created |
|-------------|-------------|--------------|---------|
""",

    "audit_entry": "- **{timestamp}**: {event}",

    "batch_card": """# Batch Provenance Card

## Batch Information
| Property | Value |
|----------|-------|
| Batch ID | `{batch_id}` |
| Session ID | `{session_id}` |
| Batch Index | {batch_index} |
| Sample Count | {sample_count} |
| Created | {created_at} |

## Sample Fingerprints
{sample_fingerprints}

---
Generated by Origin v{version} at {generated_at}
""",
}


# =============================================================================
# Helper Functions
# =============================================================================

def format_timestamp(iso_string: str) -> str:
    """
    Convert an ISO 8601 timestamp to a human-readable format.

    Args:
        iso_string: ISO 8601 formatted timestamp string.

    Returns:
        Human-readable timestamp string.

    Example:
        >>> format_timestamp("2024-01-15T14:30:00+00:00")
        'January 15, 2024 at 14:30 UTC'
    """
    if not iso_string:
        return "Unknown"

    try:
        # Handle various ISO formats
        iso_string = iso_string.replace("Z", "+00:00")

        # Try parsing with timezone
        if "+" in iso_string or iso_string.endswith("Z"):
            # Python 3.11+ has fromisoformat that handles this
            # For broader compatibility, strip microseconds and tz
            base = iso_string.split("+")[0].split("-")[0:3]
            if len(base) == 1:
                # It's just the date part before first hyphen
                base = iso_string.split("+")[0]
            else:
                base = iso_string.split("+")[0]

            if "T" in base:
                dt = datetime.fromisoformat(base.replace("Z", ""))
            else:
                dt = datetime.fromisoformat(base)
        else:
            dt = datetime.fromisoformat(iso_string)

        # Format as human-readable
        month_name = dt.strftime("%B")
        day = dt.day
        year = dt.year
        time_str = dt.strftime("%H:%M")

        return f"{month_name} {day}, {year} at {time_str} UTC"

    except (ValueError, AttributeError):
        # Return original if parsing fails
        return iso_string


def format_license_summary(analysis: Dict[str, Any]) -> str:
    """
    Format license analysis results as readable Markdown text.

    Args:
        analysis: Output from LicenseAnalyzer.propagate() or analyze_session().

    Returns:
        Formatted Markdown string with license information.
    """
    sections = []

    # Result license
    result_license = analysis.get("result_license", "unknown")
    permissions = analysis.get("permissions", ())
    restrictions = analysis.get("restrictions", ())
    conditions = analysis.get("conditions", ())

    # Format lists
    perm_str = ", ".join(permissions) if permissions else "None specified"
    rest_str = ", ".join(restrictions) if restrictions else "None specified"
    cond_str = ", ".join(conditions) if conditions else "None specified"

    sections.append(SECTION_TEMPLATES["license_result"].format(
        result_license=result_license,
        permissions=perm_str,
        restrictions=rest_str,
        conditions=cond_str,
    ))

    # Conflicts
    conflicts = analysis.get("conflicts", [])
    if conflicts:
        conflict_lines = []
        for conflict in conflicts:
            lic_a = conflict.get("license_a", "?")
            lic_b = conflict.get("license_b", "?")
            reason = conflict.get("reason", "unspecified")
            conflict_lines.append(f"- **{lic_a}** and **{lic_b}**: {reason}")

        sections.append(SECTION_TEMPLATES["license_conflicts"].format(
            conflicts="\n".join(conflict_lines)
        ))
    else:
        sections.append(SECTION_TEMPLATES["license_clean"])

    # Warnings
    warnings = analysis.get("warnings", [])
    if warnings:
        warning_lines = [f"- {w}" for w in warnings]
        sections.append(SECTION_TEMPLATES["license_warnings"].format(
            warnings="\n".join(warning_lines)
        ))

    return "\n".join(sections)


def format_table(headers: List[str], rows: List[List[str]]) -> str:
    """
    Generate a Markdown table from headers and row data.

    Args:
        headers: List of column header strings.
        rows: List of rows, where each row is a list of cell values.

    Returns:
        Formatted Markdown table string.

    Example:
        >>> headers = ["Name", "Value"]
        >>> rows = [["foo", "1"], ["bar", "2"]]
        >>> print(format_table(headers, rows))
        | Name | Value |
        |------|-------|
        | foo | 1 |
        | bar | 2 |
    """
    if not headers:
        return ""

    lines = []

    # Header row
    header_row = "| " + " | ".join(headers) + " |"
    lines.append(header_row)

    # Separator row
    separator = "|" + "|".join("-" * (len(h) + 2) for h in headers) + "|"
    lines.append(separator)

    # Data rows
    for row in rows:
        # Pad row to match headers if needed
        padded_row = list(row) + [""] * (len(headers) - len(row))
        data_row = "| " + " | ".join(str(cell) for cell in padded_row[:len(headers)]) + " |"
        lines.append(data_row)

    return "\n".join(lines)


def format_bytes(num_bytes: int) -> str:
    """
    Format a byte count as a human-readable string.

    Args:
        num_bytes: Number of bytes.

    Returns:
        Human-readable size string (e.g., "1.5 MB").
    """
    if num_bytes < 0:
        return "0 B"

    for unit in ["B", "KB", "MB", "GB", "TB"]:
        if abs(num_bytes) < 1024.0:
            return f"{num_bytes:.1f} {unit}"
        num_bytes /= 1024.0

    return f"{num_bytes:.1f} PB"


def truncate_hash(hash_str: str, length: int = 12) -> str:
    """
    Truncate a hash string for display.

    Args:
        hash_str: The hash string to truncate.
        length: Maximum length (default 12).

    Returns:
        Truncated hash with ellipsis if needed.
    """
    if len(hash_str) <= length:
        return hash_str
    return hash_str[:length] + "..."
